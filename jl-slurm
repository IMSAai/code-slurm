#!/usr/bin/env python3

import os, errno, subprocess, argparse, random, hashlib, socket, time, re, string, sys

### CONSTANTS ###
MIN_COMPUTE_PORT = 8000
MAX_COMPUTE_PORT = 9000
MIN_HEAD_PORT = 10080
MAX_HEAD_PORT = 10090
HEAD_NODE = '10.250.119.15'
HEAD_NODE_NAME = 'slurm.cluster.epochml.org'

# function to hash password for jupyter notebook file
def passwd(passphrase, algorithm='sha1'):
    # if password is empty return -1
    if(passphrase == None):
        return -1
    # return hashed password
    salt_len = 12
    h = hashlib.new(algorithm)
    salt = ('%0' + str(salt_len) + 'x') % random.getrandbits(4 * salt_len)
    h.update(str(passphrase).encode('utf-8') + str(salt).encode('ascii'))

    return ':'.join((algorithm, salt, h.hexdigest()))
    

# given a job id, returns a dictionary with all info received from qstat -f
# if job doesn't exist, returns -1
def get_job_info_slurm(job_number):    
    try:
        # run qstat command with -f option to return in lines and split them
        job_info = subprocess.check_output(['qstat', '-f', '-1', str(job_number)]).splitlines()
    except:
        # if job id doesn't exist return -1
        return -1

    # parse job string
    return parse_job_info_torque(job_info) 

# helper function to parse job raw input
def parse_job_info_torque(job_info):
    # check for empty string
    if not job_info:
	    return -1
    else:
	    # replace first string JobID: with JobID =
        job_info[0] = job_info[0].replace(":", " =")
        # remove first four characters of every entry (all spaces)
        job_info = [array_with_spaces[4:] for array_with_spaces in job_info]
        # split information into a dictionary and return it
        return dict(item.split(" = ") for item in job_info[:-1])

# checks if user is already running a jup_sched job
def check_jup_sched_slurm(username):
    jobs_name = subprocess.check_output(['squeue', '-u', username, '-t', 'RUNNING', '-h', '-o', '%j']).splitlines()
    for job in jobs_name:
        if(job == ".sbatch_jupyter"):
            return True

    return False

## given job id for slurm, returns dictionary with all info
## if job doesn't exist, returns -1
def get_job_info_slurm(job_number):
    try:
        # run scontrol with job id to view info about job
        job_info = subprocess.check_output(['scontrol',   \
                                            '--oneliner', \
                                            'show',       \
                                            'job',        \
                                            str(job_number)])
    except:
        # if job doesn't exist return -1
        return -1

    # Empty split breaks on whitespace
    job_info = job_info.split()
    # return dictionary with information
    return dict(item.decode().split("=", 1) for item in job_info) 


# deletes a file given its name with an absolute path
def delete_file(filename):
    try:
        os.remove(filename)
    except OSError as exception:
        # errno.ENOENT = no such file or directory
        if exception.errno != errno.ENOENT:
            # re-raise exception if a different error occurred 
            raise


# creates file given its name with path and content
def create_file(filename, content):
    try:
        file_object = open(filename, 'w+')
        file_object.write(content)
        file_object.close()
    except IOError as exception:
        raise


# creates a directory if it doesn't exist given filename with path
# returns 0 if dir existed or 1 if it was created
def create_dir(dir_path):
    try:
        os.makedirs(dir_path)
        return 1
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
        return 0


#given the amount of time, returns submission file header as string
def create_sbatch_header(running_time, partition, python2, email, debug, condaenv):
    header = "#!/bin/bash \
              \n#SBATCH -N 1 \
              \n#SBATCH -n 1 \
              \n#SBATCH -t 0-" + running_time
    
    if(not debug):
        header += "\n#SBATCH -o /dev/null \
                   \n#SBATCH -e /dev/null"
    header += "\n#SBATCH -p {}".format(partition)

    if email != None:
        header += "\n#SBATCH --mail-user=" + email

    header += "\nunset XDG_RUNTIME_DIR"
    header += "\n source activate {}}".format(condaenv)

    header += "\n/opt/conda/envs/conda/bin/jupyter lab --ip 0.0.0.0"

    return header


def create_jupyter_file(password, port):
    # jupyter file (OS independent)
    jupyter_dir         = "/home/" + os.getlogin() + "/.jupyter/"
    jupyter_filename    = "jupyter_notebook_config.py"

    # create content of jupyter file
    create_dir(jupyter_dir)
    create_file(jupyter_dir + jupyter_filename, create_jupyter_file_content(port, password))


def create_jupyter_file_content(port, password):
    jupyter_string = "c.NotebookApp.port = "          + \
                     str(port)                        + \
                     "\nc.NotebookApp.ip = '0.0.0.0'"       + \
                     "\nc.NotebookApp.password = u'"  + \
                     str(passwd(password)) + "'"           + \
                     "\nc.NotebookApp.open_browser = False"
  
    return jupyter_string


def schedule_jupyter_slurm(running_time, password, partition, python2, debug, email = None, condaenv = "conda"):
    # declare variable for path and name of submission
    slurm_job_filename = "/home/" + os.getlogin() + "/.jupyterlab"

    # randomize jupyter compute host port
    compute_port = random.randint(MIN_COMPUTE_PORT, MAX_COMPUTE_PORT)

    #create jupyter settings file
    create_jupyter_file(password, compute_port)

    # delete files from previous runs
    delete_file(slurm_job_filename)
    create_file(slurm_job_filename, create_sbatch_header(running_time, partition, python2, email, debug, condaenv))

    # run scheduler file and get job id
    submission_response = subprocess.check_output(['sbatch', slurm_job_filename])
    job_id = int(submission_response.decode().split('Submitted batch job ',1)[1])

    # wait for job scheduling
    print("[jupyter_scheduler INFO] Waiting for scheduler...")
    schedule_return = wait_for_schedule_slurm(job_id, compute_port)
    if(schedule_return == 0):
       print("Your job took more than 1 minute to schedule, cancel")
       return -1
    elif(schedule_return == 1):
       head_port = find_open_port_head()
    else:
        return -1
    
    # make ssh connection    
    ssh_local_forward(get_job_info_slurm(job_id).get('BatchHost'), compute_port, head_port)
    return head_port

# retrieve and parse job information use while and time.sleep to wait
# Return: 0 = timeout
#         1 = server is running on port
#        -1 = unknown error
def wait_for_schedule_slurm(job_id, compute_port, max_seconds = 60):
    counter = 0
    while(1):
        job_info = get_job_info_slurm(job_id)
        if(job_info.get('JobState') == 'RUNNING' or counter == max_seconds):
            break
        else:
            time.sleep(1)
            counter = counter + 1
   
    if(counter == max_seconds):
        return 0
    elif(port_use_checker(job_info.get('BatchHost'), compute_port) == 0):
	    return 1
    else:
        return -1


def ssh_local_forward(host, compute_port, head_port):
    subprocess.call(['ssh',
                     '-M', '-N', '-f', '-T', '-L',
                      HEAD_NODE+":"+str(head_port)+':'+host+':'+str(compute_port),host])    

# returns open port
# returns -1 if no port in range is available
def find_open_port_head():
    port = random.randint(MIN_HEAD_PORT, MAX_HEAD_PORT)
    for i in range(0, MAX_HEAD_PORT - MIN_HEAD_PORT):
        if str(port) not in subprocess.check_output(['netstat', '-an']).decode():
            return port
        else:
            port = port + 1 if (port + 1 <= MAX_HEAD_PORT) else MIN_HEAD_PORT

    return -1

# Given a host and a port checks if port is listening
def port_use_checker(host, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    result = sock.connect_ex((host,port))
    if result == 0:
       return 1 # port is open
    else:
       return 0

# Validate walltime entered
def valid_walltime(s):
    split = s.split(":")
    if(len(split) != 3 or (all(len(i) == 2 for i in split) == False)):
        raise argparse.ArgumentTypeError("invalid format for time")

    if(not (
       (0 <= int(split[0]) <= 99) and 
       (0 <= int(split[1]) <  60) and 
       (0 <= int(split[2]) <  60))):
	    raise argparse.ArgumentTypeError("invalid format for time") 
    
    if((int(split[0]) > 24) or (
       (int(split[0]) == 24) and (
       (int(split[1]) > 0) or
       (int(split[2]) > 0)))):
        raise argparse.ArgumentTypeError("maximum walltime permitted is 24:00:00")

    return s

# Print password
def print_pass():
    filename = "/home/" + os.getlogin() + "/.jupyter/.jupyter_pass"
    try:
        file = open(filename, 'r')
        info = file.read().split(',')
        print(
        """
==================================== 
Please direct your browser to:
{}
Use the password:
{}
to login.
====================================
Run \"jup_sched --password\" to view this message again
        """.format(info[0], info[1])
        )
    except IOError:
        print("[jupyter_scheduler ERROR] could not find your info, are you sure you have a notebook scheduled?")

def gen_password():
    length = 12
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    return result_str
#========================================================================================================
parser = argparse.ArgumentParser(description="Jupyter Notebook Scheduler")
# options which require arguments
parser.add_argument("-e",
                    "--email",
                    type=str,
                    help="specify an email address for the scheduler communication")

parser.add_argument("-t",
                    "--time",
                    type=valid_walltime,
                    help="specify the running time for the scheduler in the format HH:MM:SS")

parser.add_argument("-p",
                    "--partition",
                    type=str,
                    help="specify the partition to run the job in")

parser.add_argument("-c",
                    "--condaenv",
                    type=str,
                    help="specify the conda environment to activate")
# options which do not require arguments

parser.add_argument("-py2",
                    "--python2",
                    action="store_true",
                    help="use a Python 2.x environment (Python 3.x is used by default)")

parser.add_argument("--password",
                    action="store_true",
                    help="re-print the password and address for the jupyter notebook \
		          WILL IGNORE ALL OTHER ARGUMENTS")

parser.add_argument("-d",
                    "--debug",
                    action="store_true",
                    help="keep the scheduler's transcript of the console output (off by default)")


args = parser.parse_args()
password = gen_password()

ret_val = 0

# checks for running instances
running_bool = check_jup_sched_slurm(os.getlogin())
if len(sys.argv) == 1:
    parser.print_help()
    raise SystemExit()
elif(running_bool and (not args.password)):
    print("[jupyter_scheduler ERROR] you already have a scheduled jupyter notebook. We only support one notebook per user at this time.")
    raise SystemExit()
elif((not running_bool) and args.password):
    print("[jupyter_scheduler ERROR] you don't have a notebook scheduled.")
    raise SystemExit()
elif(running_bool and args.password):
    print_pass()
    raise SystemExit()
elif(args.time == None):
   print("[jupyter_scheduler INFO] no time on arguments, scheduling notebook for 1 HOUR")
   ret_val = schedule_jupyter_slurm("01:00:00", password, args.partition, args.python2, args.debug, args.email)
else: 
   ret_val = schedule_jupyter_slurm(args.time, password, args.partition, args.python2, args.debug, args.email, args.condaenv)

if MIN_HEAD_PORT <= ret_val <= MAX_HEAD_PORT:
    create_file("/home/" + os.getlogin() + "/.jupyter/.jupyter_pass",
                "http://" + HEAD_NODE_NAME + ":" + str(ret_val) + "," + password + "\n")
    print_pass()